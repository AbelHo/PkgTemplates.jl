"""
    generate(pkg_name::AbstractString, t::Template) -> Void

Generate a package from a template.

# Arguments
* `pkg_name::AbstractString`: Name of the package.
* `t::Template`: The template from which to generate the package.

# Keyword Arguments
* `force::Bool=false`: Whether or not to overwrite old packages with the same name.
"""
function generate(pkg_name::AbstractString, t::Template; force::Bool=false)
    pkg_name = Pkg.splitjl(pkg_name)
    pkg_dir = joinpath(t.path, pkg_name)

    if force && ispath(pkg_dir)
        rm(pkg_dir; recursive=true)
    elseif ispath(pkg_dir)
        throw(ArgumentError(
            "A directory already exists at $pkg_dir, use force=true to overwrite it."
        ))
    end

    # Initialize the repo and configure it.
    repo = LibGit2.init(pkg_dir)
    info("Initialized git repo at $pkg_dir")
    cfg = LibGit2.GitConfig(repo)
    info("Configuring git")
    for (key, val) in t.git_config
        LibGit2.set!(cfg, key, val)
    end
    info("Finished configuring git")
    url = "$(t.remote_prefix)$pkg_name.jl"
    LibGit2.commit(repo, "Empty initial commit")
    info("Made initial empty commit")
    LibGit2.set_remote_url(repo, url)
    info("Set remote origin to $url")

    # Create the gh-pages branch if necessary.
    if haskey(t.plugins, GitHubPages)
        LibGit2.branch!(repo, "gh-pages")
        LibGit2.commit(repo, "Empty initial commit")
        info("Created empty gh-pages branch")
        LibGit2.branch!(repo, "master")
    end

    # Generate plugin files and common stuff like tests/entrypoint/readme.
    # File generation functions that fail should return nothing.
    files = filter(x -> x != nothing, [
        gen_license(pkg_dir, t.license, t.authors, t.years),
        gen_entrypoint(pkg_dir),
        gen_require(pkg_dir, t.julia_version),
        gen_tests(pkg_dir),
        gen_readme(pkg_dir, t),
        gen_gitignore(pkg_dir, t.plugins),
    ])

    for plugin in values(t.plugins)
        plugin_files = gen_plugin(plugin, t, pkg_name)
        append!(files, plugin_files)
        info("Generated files/directories: $(join(plugin_files, ", "))")
    end

    LibGit2.add!(repo, files...)
    info("Staged $(length(files)) files/directories: $(join(files, ", "))")
    LibGit2.commit(repo, "Files generated by PkgTemplates")
    info("Committed files generated by PkgTemplates")
    info("Finished")
    warn("Remember to push all created branches to your remote: git push --all -u")
end

"""
    gen_readme(pkg_dir::AbstractString, t::Template) -> String

Generate a README with badges for each enabled plugin.

# Arguments
* `pkg_dir::AbstractString`: The package directory.
* `t::Template`: The template whose README we are generating.

Returns the name of the generated file.
"""
function gen_readme(pkg_dir::AbstractString, t::Template)
    pkg_name = basename(pkg_dir)
    text = "# $pkg_name\n"

    # We want badges to be laid out: docs -> CI -> coverage.
    ordering = [GitHubPages, TravisCI, AppVeyor, CodeCov]
    for plugin_type in ordering
        if haskey(t.plugins, plugin_type)
            text *= "\n" * join(badges(t.plugins[plugin_type], t, pkg_name), "\n")
        end
    end

    gen_file(joinpath(pkg_dir, "README.md"), text)
    return "README.md"
end

"""
    gen_gitignore(pkg_dir, plugins) -> Union{String,Void}

Generate a .gitignore from the list of enabled `plugins`.

# Arguments
* `pkg_dir::AbstractString`: The package directory.
* `plugins::Dict{DataType, Plugin}`: The enabled plugins.

Returns the name of the generated file.
"""
function gen_gitignore(pkg_dir::AbstractString, plugins::Dict{DataType,Plugin})
    text = ".DS_Store\n"
    for plugin in values(plugins)
        if !isempty(plugin.gitignore_files)
            text *= join(plugin.gitignore_files, "\n") * "\n"
        end
    end

    gen_file(joinpath(pkg_dir, ".gitignore"), text)
    return ".gitignore"
end

"""
    gen_license(pkg_dir, license, authors, years) -> Union{String, Void}

Creates a license file for the package.

# Arguments
* `pkg_dir::AbstractString`: The package directory.
* `license::Union{AbstractString, Void}`: Name of the license, `nothing` if no license.
* `authors::AbstractString`: Author, or comma-delimited list of authors, of the package.
* `years::AbstractString`: Copyright year or range of copyright years.

Returns the name of the generated file, or `nothing` in the case that
no license is generated.
"""
function gen_license(
    pkg_dir::AbstractString,
    license::Union{AbstractString, Void},
    authors::AbstractString,
    years::AbstractString
)
    if license == nothing
        return nothing
    end

    pkg_name = basename(pkg_dir)
    text = "Copyright (c) $years $authors\n" * read_license(license)

    gen_file(joinpath(pkg_dir, "LICENSE"), text)
    return "LICENSE"
end

"""
    gen_entrypoint(pkg_dir::AbstractString) -> String

Creates the module entrypoint ("src/\$pkg_name.jl") in `pkg_dir`.

# Arguments
* `pkg_dir::AbstractString`: The package directory.

Returns the name of the generated directory.
"""
function gen_entrypoint(pkg_dir::AbstractString)
    pkg_name = basename(pkg_dir)
    text = """
        module $pkg_name

        # Package code goes here.

        end
        """

    gen_file(joinpath(pkg_dir, "src", "$pkg_name.jl"), text)
    return "src/"
end

"""
    gen_require(pkg_dir::AbstractString, julia_version::VersionNumber) -> String

Create the requirements file in the package directory.

# Arguments
* `pkg_dir::AbstractString`: The package directory.
* `julia_version::VersionNumber`: The minimum Julia version to support.

Returns the name of the generated file.
"""
function gen_require(pkg_dir::AbstractString, julia_version::VersionNumber)
    text = "julia $(version_floor(julia_version))\n"

    gen_file(joinpath(pkg_dir, "REQUIRE"), text)
    return "REQUIRE"
end

"""
    gen_tests(pkg_dir::AbstractString) -> String

Creates the test file "test/runtests.jl" in the package directory.

# Arguments
* `pkg_dir::AbstractString`: The package directory.

Returns the name of the generated directory.
"""
function gen_tests(pkg_dir::AbstractString)
    text = """
        using $(basename(pkg_dir))
        using Base.Test

        # Write your own tests here.
        @test 1 == 2
        """

    gen_file(joinpath(pkg_dir, "test", "runtests.jl"), text)
    return "test/"
end

"""
    gen_file(file_path::AbstractString, text::AbstractString) -> Int

Create a new file containing some given text. Always ends the file with a newline.

# Arguments
* `file::AbstractString`: Path to the file to be created.
* `text::AbstractString`: Text to write to the file.

Returns the number of bytes written to the file.
"""
function gen_file(file::AbstractString, text::AbstractString)
    mkpath(dirname(file))
    if !endswith(text , "\n")
        text *= "\n"
    end
    open(file, "w") do fp
        return write(fp, text)
    end
end

"""
    version_floor(v::VersionNumber=VERSION) -> String

Format the given Julia version.

# Keyword arguments
* `v::VersionNumber=VERSION`: Version to floor.

Returns "major.minor" for the most recent release version relative to v. For prereleases
with v.minor == v.patch == 0, returns "major.minor-".
"""
function version_floor(v::VersionNumber=VERSION)
    if isempty(v.prerelease) || v.patch > 0
        return "$(v.major).$(v.minor)"
    else
        return "$(v.major).$(v.minor)-"
    end
end

"""
    substitute(
        template::AbstractString,
        pkg_name::AbstractString,
        pkg_template::Template;
        view::Dict{String, Any}=Dict{String, Any}(),
    ) -> String

Replace placeholders in `template`. The input string is not modified.

# Arguments:
* `template::AbstractString`: Template string to make replacements in.
* `pkg_name::AbstractString`: Name of the package being created.
* `pkg_template::Template`: The package template in use.
* `view::Dict{String, Any}=Dict{String, Any}()`: Additional values to be substituted.

Returns the text with substitutions applied.
"""
function substitute(
    template::AbstractString,
    pkg_name::AbstractString,
    pkg_template::Template;
    view::Dict{String, Any}=Dict{String, Any}(),
)
    # Don't use version_floor here because we don't want the trailing '-' on prereleases.
    d = merge!(Dict{String, Any}(), view)
    d["PKGNAME"] = pkg_name
    v = pkg_template.julia_version
    d["VERSION"] = "$(v.major).$(v.minor)"
    # d["AFTER"] is true whenever something needs to occur in a CI "after_script".
    if any(isa(p, Documenter) for p in values(pkg_template.plugins))
        d["DOCUMENTER"] = true
        d["AFTER"] = true
    end
    if haskey(pkg_template.plugins, CodeCov)
        d["CODECOV"] = true
        d["AFTER"] = true
    end
    return render(template, d)
end
