"""
    generate(pkg_name::AbstractString, t::Template) -> Nothing

Generate a package named `pkg_name` from `t`.
"""
function generate(pkg_name::AbstractString, t::Template)
    pkg_dir = joinpath(t.dir, pkg_name)
    ispath(pkg_dir) && throw(ArgumentError("$pkg_dir already exists"))

    try
        pkg_name = splitjl(pkg_name)
        pkg_dir = joinpath(t.dir, pkg_name)

        # Create the directory with some boilerplate inside.
        Pkg.generate(pkg_dir)

        # Initialize the repo.
        repo = LibGit2.init(pkg_dir)
        @info "Initialized git repo at $pkg_dir"
        LibGit2.commit(repo, "Initial commit")
        rmt = if t.ssh
            "git@$(t.host):$(t.user)/$pkg_name.jl.git"
        else
            "https://$(t.host)/$(t.user)/$pkg_name.jl"
        end
        # We need to set the remote in a strange way, see #8.
        close(LibGit2.GitRemote(repo, "origin", rmt))
        @info "Set remote origin to $rmt"

        # Create the gh-pages branch if necessary.
        if haskey(t.plugins, GitHubPages)
            LibGit2.branch!(repo, "gh-pages")
            LibGit2.commit(repo, "Empty initial commit")
            @info "Created empty gh-pages branch"
            LibGit2.branch!(repo, "master")
        end

        # Generate the files.
        files = vcat(
            "src/", "Project.toml",  # Created by Pkg.generate.
            gen_tests(pkg_dir, t),
            gen_require(pkg_dir, t),
            gen_readme(pkg_dir, t),
            gen_gitignore(pkg_dir, t),
            gen_license(pkg_dir, t),
            vcat(map(p -> gen_plugin(p, t, t.dir, pkg_name), values(t.plugins))...),
        )

        LibGit2.add!(repo, files...)
        LibGit2.commit(repo, "Files generated by PkgTemplates")
        @info "Staged and committed $(length(files)) files/directories: $(join(files, ", "))"

        @info "Finished"
        if length(collect(LibGit2.GitBranchIter(repo))) > 1
            @info "Remember to push all created branches to your remote: git push --all"
        end
    catch e
        rm(pkg_dir; recursive=true)
        rethrow(e)
    end
end

generate(t::Template, pkg_name::AbstractString) = generate(pkg_name, t)

"""
    generate_interactive(pkg::AbstractString; fast::Bool=false) -> Nothing

Interactively create a template, and then generate a package with it. Arguments and
keywords are used in the same way as in [`generate`](@ref) and
[`interactive_template`](@ref).
"""
function generate_interactive(pkg::AbstractString; fast::Bool=false)
    generate(pkg, interactive_template(; fast=fast))
end

"""
    gen_tests(pkg_dir::AbstractString, t::Template) -> Vector{String}

Create the test entrypoint in `pkg_dir`.

# Arguments
* `pkg_dir::AbstractString`: The package directory in which the files will be generated
* `t::Template`: The template whose tests we are generating.

Returns an array of generated file/directory names.
"""
function gen_tests(pkg_dir::AbstractString, t::Template)
    proj = Base.current_project()
    try
        Pkg.activate(pkg_dir)
        Pkg.add("Test")
    finally
        # TODO: What should we do if there is no current project?
        # Activating the generated project is now a side effect.
        proj !== nothing && Pkg.activate(dirname(proj))
    end

    pkg = basename(pkg_dir)
    text = """
        using $pkg
        using Test

        @testset "$pkg.jl" begin
            # Write your own tests here.
            @test 1 == 2
        end
        """

    gen_file(joinpath(pkg_dir, "test", "runtests.jl"), text)
    # TODO: Should we be checking Manifest.toml into Git?
    return ["Manifest.toml", "test/"]
end

"""
    gen_require(pkg_dir::AbstractString, t::Template) -> Vector{String}

Create the `REQUIRE` file in `pkg_dir`.

# Arguments
* `pkg_dir::AbstractString`: The directory in which the files will be generated.
* `t::Template`: The template whose REQUIRE we are generating.

Returns an array of generated file/directory names.
"""
function gen_require(pkg_dir::AbstractString, t::Template)
    text = "julia $(version_floor(t.julia_version))\n"
    gen_file(joinpath(pkg_dir, "REQUIRE"), text)
    return ["REQUIRE"]
end

"""
    gen_readme(pkg_dir::AbstractString, t::Template) -> Vector{String}

Create a README in `pkg_dir` with badges for each enabled plugin.

# Arguments
* `pkg_dir::AbstractString`: The directory in which the files will be generated.
* `t::Template`: The template whose README we are generating.

Returns an array of generated file/directory names.
"""
function gen_readme(pkg_dir::AbstractString, t::Template)
    pkg = basename(pkg_dir)
    text = "# $pkg\n"
    done = []
    # Generate the ordered badges first, then add any remaining ones to the right.
    for plugin_type in BADGE_ORDER
        if haskey(t.plugins, plugin_type)
            text *= "\n"
            text *= join(
                badges(t.plugins[plugin_type], t.user, pkg),
                "\n",
            )
            push!(done, plugin_type)
        end
    end
    for plugin_type in setdiff(keys(t.plugins), done)
        text *= "\n"
        text *= join(
            badges(t.plugins[plugin_type], t.user, pkg),
            "\n",
        )
    end

    gen_file(joinpath(pkg_dir, "README.md"), text)
    return ["README.md"]
end

"""
    gen_gitignore(pkg_dir::AbstractString, t::Template) -> Vector{String}

Create a `.gitignore` in `pkg_dir`.

# Arguments
* `pkg_dir::AbstractString`: The directory in which the files will be generated.
* `t::Template`: The template whose .gitignore we are generating.

Returns an array of generated file/directory names.
"""
function gen_gitignore(pkg_dir::AbstractString, t::Template)
    pkg = basename(pkg_dir)
    seen = [".DS_Store"]
    patterns = vcat(map(p -> p.gitignore, values(t.plugins))...)
    for pattern in patterns
        if !in(pattern, seen)
            push!(seen, pattern)
        end
    end
    text = join(seen, "\n")

    gen_file(joinpath(pkg_dir, ".gitignore"), text)
    return [".gitignore"]
end

"""
    gen_license(pkg_dir::AbstractString, t::Template) -> Vector{String}

Create a license in `pkg_dir`.

# Arguments
* `pkg_dir::AbstractString`: The directory in which the files will be generated.
* `t::Template`: The template whose LICENSE we are generating.

Returns an array of generated file/directory names.
"""
function gen_license(pkg_dir::AbstractString, t::Template)
    if isempty(t.license)
        return String[]
    end

    text = "Copyright (c) $(Dates.year(Dates.now())) $(t.authors)\n"
    text *= read_license(t.license)

    gen_file(joinpath(pkg_dir, "LICENSE"), text)
    return ["LICENSE"]
end

"""
    gen_file(file::AbstractString, text::AbstractString) -> Int

Create a new file containing some given text. Always ends the file with a newline.

# Arguments
* `file::AbstractString`: Path to the file to be created.
* `text::AbstractString`: Text to write to the file.

Returns the number of bytes written to the file.
"""
function gen_file(file::AbstractString, text::AbstractString)
    mkpath(dirname(file))
    if !endswith(text , "\n")
        text *= "\n"
    end
    return write(file, text)
end

"""
    version_floor(v::VersionNumber=VERSION) -> String

Format the given Julia version.

# Keyword arguments
* `v::VersionNumber=VERSION`: Version to floor.

Returns "major.minor" for the most recent release version relative to v. For prereleases
with v.minor == v.patch == 0, returns "major.minor-".
"""
function version_floor(v::VersionNumber=VERSION)
    return if isempty(v.prerelease) || v.patch > 0
        "$(v.major).$(v.minor)"
    else
        "$(v.major).$(v.minor)-"
    end
end

"""
    substitute(template::AbstractString, view::Dict{String, Any}) -> String
    substitute(
        template::AbstractString,
        pkg_template::Template;
        view::Dict{String, Any}=Dict{String, Any}(),
    ) -> String

Replace placeholders in `template` with values in `view` via
[`Mustache`](https://github.com/jverzani/Mustache.jl). `template` is not modified.
If `pkg_template` is supplied, some default replacements are also performed.

For information on how to structure `template`, see "Defining Template Files" section in
[Custom Plugins](@ref).

**Note**: Conditionals in `template` without a corresponding key in `view` won't error,
but will simply be evaluated as false.
"""
substitute(template::AbstractString, view::Dict{String, Any}) = render(template, view)

function substitute(
    template::AbstractString,
    pkg_template::Template;
    view::Dict{String, Any}=Dict{String, Any}(),
)
    # Don't use version_floor here because we don't want the trailing '-' on prereleases.
    v = pkg_template.julia_version
    d = Dict{String, Any}(
        "USER" => pkg_template.user,
        "VERSION" => "$(v.major).$(v.minor)",
        "DOCUMENTER" => any(map(p -> isa(p, Documenter), values(pkg_template.plugins))),
        "CODECOV" => haskey(pkg_template.plugins, CodeCov),
        "COVERALLS" => haskey(pkg_template.plugins, Coveralls),
    )
    # d["AFTER"] is true whenever something needs to occur in a CI "after_script".
    d["AFTER"] = d["DOCUMENTER"] || d["CODECOV"] || d["COVERALLS"]
    return substitute(template, merge(d, view))
end

"""
    splitjl(pkg::AbstractString) -> AbstractString

Remove ".jl" from the end of a package name if it is present.
"""
splitjl(pkg::AbstractString) = endswith(pkg, ".jl") ? pkg[1:end-3] : pkg
